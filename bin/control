#!/bin/bash

# Determine the program name and the 'running directory'
IAM="${0##*/}"
CRD="$( [[ "${0:0:2}" = "./" ]] &&
	{	printf "${PWD}/${0#./}"
	} || {
		printf "${0}"
	})"
CRD="${CRD%/*}"
CUR="${PWD}"

# Make sure all language settings are correct
export LANG=C

# Make sure encoding is set to UTF-8, this is needed for Webdav file encoding
export LC_ALL=en_US.UTF-8

# Save the shell settings
SETA=0; [[ ${-} = *a* ]] && SETA=1
SETE=0; [[ ${-} = *e* ]] && SETE=1
SETU=0; [[ ${-} = *u* ]] && SETU=1
SETX=0; [[ ${-} = *x* ]] && SETX=1

# Set and unset the needed shell settings
set +o noclobber		# Overwrite existing files, if needed
set -o nounset			# Do not allow uninitialized variables
set +o errexit			# No returncode checking

# Set the PATH
PATH=/bin:/usr/bin:${PATH}

# Read the OpenShift functions
source ${OPENSHIFT_CARTRIDGE_SDK_BASH}

# Set constants and read constants
LIBDIR="${CRD}/../lib"
LIBRARY="${LIBDIR}/library"
[[ ! -r ${LIBRARY} ]] && { echo "${LIBRARY} not found"; exit 1; }
. ${LIBRARY} || { echo "Error reading ${LIBRARY}"; exit 1; }


# Check if the process is running
# ${1} is the PID file for the app (Tomcat / Wildfly)
isrunning() {
	PIDFILE="${1}"

	# Check for running app
	if [[ -f "${PIDFILE}" ]]
	then
		running=$(/bin/ps --no-headers --pid $(<${PIDFILE}))
		if [[ x"${running}" = x"" ]]
		then
			# Not running
			return 1
		else
			# running
			return 0
		fi
	fi

	# No PID file. Not running
	return 1
}


# Kill the process given by ${1} and its children
killtree() {
	local _pid="${1}"
	showstatus "0" "killtree ${1}"
	for _child in $(ps -o pid --no-headers --ppid ${_pid})
	do
		killtree ${_child}
	done

	local should_be_gone_pid=$(ps -o pid -p ${_pid} --no-headers)
	if [[ x"${should_be_gone_pid}" = x"" ]]
	then
		return
	else
		# process might have finished stopping after the ps check above
		# so prevent kill from throwing an error
		# with || true
		kill -TERM ${_pid} || true
	fi

	local count=0
	while [[ ${count} -lt 15 ]]
	do
		local should_be_gone_pid=$(ps -o pid -p ${_pid} --no-headers)
		if [[ x"${should_be_gone_pid}" = x"" ]]
		then
			return
		else
			sleep 2
			count=$(( ${count} + 1 ))
		fi
	done

	local should_be_gone_pid=$(ps -o pid -p ${_pid} --no-headers)
	if [[ x"${should_be_gone_pid}" != x"" ]]
	then
		kill -9 ${_pid}
	fi
}


start()
{
	client_result "0" "Start Keycloak cartridge runtime"
	if marker_present "enable_jpda"
  then
    export ENABLE_JPDA=1
  fi

  # Check for running app
  if isrunning
   then
      echo "Application is already running"
  else
    export RUXIT_CLUSTER_ID=${OPENSHIFT_APP_DNS}-wildfly
    ${WILDFLY_BIN_DIR}/standalone.sh -b $OPENSHIFT_WILDFLY_IP -bmanagement=$OPENSHIFT_WILDFLY_IP -Dh2.bindAddress=$OPENSHIFT_WILDFLY_IP > $OPENSHIFT_PLNKEYCLK_DIR/logs/server.log 2>&1 &
    PROCESS_ID=$!
    echo "$PROCESS_ID" > ${WILDFLY_PID_FILE}   
  fi
}

stop()
{
	echo "Stopping $cartridge_type cart"

	if isrunning; then
    	if [ -f "$WILDFLY_PID_FILE" ]; then
	      pid=$(cat $WILDFLY_PID_FILE);
    	  echo "Sending SIGTERM to wildfly:$pid ..." 1>&2
      	killtree $pid
    	else
      		echo "Failed to locate WildFly PID File" 1>&2
    	fi
  	fi
}

restart()
{
	echo "Restarting $cartridge_type cart"
	stop 
	sleep 5
	start 
}

status()
{
   if isrunning
   then
      client_result "Application is running"
   else
      client_result "Application is either stopped or inaccessible"
   fi
}

tidy()
{
	client_message "Emptying log dir: $OPENSHIFT_WILDFLY_LOG_DIR"
  shopt -s dotglob
  rm -rf $OPENSHIFT_WILDFLY_LOG_DIR/*
}

catchall()
{
	showstatus "0" "	${1:-}: not yet implemented"

	return 0
}


showstatus "0" "Control Main called"
case "${1:-}"
in
	start)					start   "${2:-all}"	     ;;
	stop)					stop    "${2:-all}"	     ;;
	restart)				restart	"${2:-all}"	     ;;
	status)					status				     ;;   
	tidy)					tidy                     ;;
	deploy)					catchall "${1}"		     ;;
	reload)					catchall "${1}"	         ;;
	pre-build)				catchall "${1}"	         ;;
	build)					catchall "${1}"	         ;;
	post-deploy)			catchall "${1}"	         ;;
	pre-repo-archive)		catchall "${1}"	         ;;
	update-configuration)	catchall "${1}"	         ;;
	*)						catchall "Unknown"       ;;
esac

# Exit. No exit code!! The exit code will be the exit code
# of the last run process!!
exit
